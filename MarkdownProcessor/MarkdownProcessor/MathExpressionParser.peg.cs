// -----------------------------------------------------------------------
// <auto-generated>
//   This code was generated by Pegasus 3.0.0.0
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
// </auto-generated>
// -----------------------------------------------------------------------

namespace
#line 1 "MathExpressionParser.peg"
           PegExamples
#line default
{
    using System;
    using System.Collections.Generic;
    using Pegasus.Common;
    using
        #line 3 "MathExpressionParser.peg"
       Pegasus.Common
        #line default
        ;

    /// <summary>
    ///  Parses a string according to the rules of the <see cref="MathExpressionParser" /> grammar.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("Pegasus", "3.0.0.0")]
    public
    partial class
    #line 2 "MathExpressionParser.peg"
           MathExpressionParser
    #line default
    {
        private Dictionary<string, object> storage;

        /// <summary>
        ///  Parses a string according to the rules of the <see cref="MathExpressionParser" /> grammar.
        /// </summary>
        /// <param name="subject">The parsing subject.</param>
        /// <param name="fileName">The optional file name to use in error messages.</param>
        /// <returns>The <see cref="decimal" /> parsed from <paramref name="subject" />.</returns>
        /// <exception cref="FormatException">
        ///  Thrown when parsing fails against <paramref name="subject"/>.  The exception's <code>Data["cursor"]</code> will be set with the cursor where the fatal error occurred.
        /// </exception>
        public decimal Parse(string subject, string fileName = null)
        {
            try
            {
                this.storage = new Dictionary<string, object>();
                var cursor = new Cursor(subject, 0, fileName);
                var result = this.start(ref cursor);
                if (result == null)
                {
                    throw ExceptionHelper(cursor, state => "Failed to parse 'start'.");
                }
                return result.Value;
            }
            finally
            {
                this.storage = null;
            }
        }

        private IParseResult<
            #line 5 "MathExpressionParser.peg"
       decimal
            #line default
            > start(ref Cursor cursor)
        {
            IParseResult<decimal> r0 = null;
            var startCursor0 = cursor;
            IParseResult<decimal> r1 = null;
            var valueStart = cursor;
            r1 = this.additive(ref cursor);
            var valueEnd = cursor;
            var value = ValueOrDefault(r1);
            if (r1 != null)
            {
                IParseResult<string> r2 = null;
                r2 = this.EOF(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<decimal>(startCursor0, cursor, state =>
                        #line 6 "MathExpressionParser.peg"
                         value
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<
            #line 8 "MathExpressionParser.peg"
          decimal
            #line default
            > additive(ref Cursor cursor)
        {
            IParseResult<decimal> r0 = null;
            if (r0 == null)
            {
                var startCursor0 = cursor;
                IParseResult<decimal> r1 = null;
                var leftStart = cursor;
                r1 = this.multiplicative(ref cursor);
                var leftEnd = cursor;
                var left = ValueOrDefault(r1);
                if (r1 != null)
                {
                    IParseResult<string> r2 = null;
                    r2 = this.add(ref cursor);
                    if (r2 != null)
                    {
                        IParseResult<decimal> r3 = null;
                        var rightStart = cursor;
                        r3 = this.additive(ref cursor);
                        var rightEnd = cursor;
                        var right = ValueOrDefault(r3);
                        if (r3 != null)
                        {
                            r0 = this.ReturnHelper<decimal>(startCursor0, cursor, state =>
                                #line 9 "MathExpressionParser.peg"
                                             left + right
                                #line default
                                );
                        }
                        else
                        {
                            cursor = startCursor0;
                        }
                    }
                    else
                    {
                        cursor = startCursor0;
                    }
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            if (r0 == null)
            {
                var startCursor1 = cursor;
                IParseResult<decimal> r4 = null;
                var leftStart = cursor;
                r4 = this.multiplicative(ref cursor);
                var leftEnd = cursor;
                var left = ValueOrDefault(r4);
                if (r4 != null)
                {
                    IParseResult<string> r5 = null;
                    r5 = this.sub(ref cursor);
                    if (r5 != null)
                    {
                        IParseResult<decimal> r6 = null;
                        var rightStart = cursor;
                        r6 = this.additive(ref cursor);
                        var rightEnd = cursor;
                        var right = ValueOrDefault(r6);
                        if (r6 != null)
                        {
                            r0 = this.ReturnHelper<decimal>(startCursor1, cursor, state =>
                                #line 10 "MathExpressionParser.peg"
                                             left - right
                                #line default
                                );
                        }
                        else
                        {
                            cursor = startCursor1;
                        }
                    }
                    else
                    {
                        cursor = startCursor1;
                    }
                }
                else
                {
                    cursor = startCursor1;
                }
            }
            if (r0 == null)
            {
                r0 = this.multiplicative(ref cursor);
            }
            return r0;
        }

        private IParseResult<
            #line 13 "MathExpressionParser.peg"
                decimal
            #line default
            > multiplicative(ref Cursor cursor)
        {
            IParseResult<decimal> r0 = null;
            var storageKey = "multiplicative:" + cursor.StateKey + ":" + cursor.Location;
            if (this.storage.ContainsKey(storageKey))
            {
                r0 = (IParseResult<decimal>)this.storage[storageKey];
                if (r0 != null)
                {
                    cursor = r0.EndCursor;
                }
                return r0;
            }
            if (r0 == null)
            {
                var startCursor0 = cursor;
                IParseResult<decimal> r1 = null;
                var leftStart = cursor;
                r1 = this.primary(ref cursor);
                var leftEnd = cursor;
                var left = ValueOrDefault(r1);
                if (r1 != null)
                {
                    IParseResult<string> r2 = null;
                    r2 = this.mul(ref cursor);
                    if (r2 != null)
                    {
                        IParseResult<decimal> r3 = null;
                        var rightStart = cursor;
                        r3 = this.multiplicative(ref cursor);
                        var rightEnd = cursor;
                        var right = ValueOrDefault(r3);
                        if (r3 != null)
                        {
                            r0 = this.ReturnHelper<decimal>(startCursor0, cursor, state =>
                                #line 14 "MathExpressionParser.peg"
                                            left * right
                                #line default
                                );
                        }
                        else
                        {
                            cursor = startCursor0;
                        }
                    }
                    else
                    {
                        cursor = startCursor0;
                    }
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            if (r0 == null)
            {
                var startCursor1 = cursor;
                IParseResult<decimal> r4 = null;
                var leftStart = cursor;
                r4 = this.primary(ref cursor);
                var leftEnd = cursor;
                var left = ValueOrDefault(r4);
                if (r4 != null)
                {
                    IParseResult<string> r5 = null;
                    r5 = this.div(ref cursor);
                    if (r5 != null)
                    {
                        IParseResult<decimal> r6 = null;
                        var rightStart = cursor;
                        r6 = this.multiplicative(ref cursor);
                        var rightEnd = cursor;
                        var right = ValueOrDefault(r6);
                        if (r6 != null)
                        {
                            r0 = this.ReturnHelper<decimal>(startCursor1, cursor, state =>
                                #line 15 "MathExpressionParser.peg"
                                            left / right
                                #line default
                                );
                        }
                        else
                        {
                            cursor = startCursor1;
                        }
                    }
                    else
                    {
                        cursor = startCursor1;
                    }
                }
                else
                {
                    cursor = startCursor1;
                }
            }
            if (r0 == null)
            {
                r0 = this.primary(ref cursor);
            }
            this.storage[storageKey] = r0;
            return r0;
        }

        private IParseResult<
            #line 18 "MathExpressionParser.peg"
         decimal
            #line default
            > primary(ref Cursor cursor)
        {
            IParseResult<decimal> r0 = null;
            var storageKey = "primary:" + cursor.StateKey + ":" + cursor.Location;
            if (this.storage.ContainsKey(storageKey))
            {
                r0 = (IParseResult<decimal>)this.storage[storageKey];
                if (r0 != null)
                {
                    cursor = r0.EndCursor;
                }
                return r0;
            }
            if (r0 == null)
            {
                r0 = this.@decimal(ref cursor);
            }
            if (r0 == null)
            {
                var startCursor0 = cursor;
                IParseResult<string> r1 = null;
                r1 = this.lParen(ref cursor);
                if (r1 != null)
                {
                    IParseResult<decimal> r2 = null;
                    var additiveStart = cursor;
                    r2 = this.additive(ref cursor);
                    var additiveEnd = cursor;
                    var additive = ValueOrDefault(r2);
                    if (r2 != null)
                    {
                        IParseResult<string> r3 = null;
                        r3 = this.rParen(ref cursor);
                        if (r3 != null)
                        {
                            r0 = this.ReturnHelper<decimal>(startCursor0, cursor, state =>
                                #line 20 "MathExpressionParser.peg"
                                      additive
                                #line default
                                );
                        }
                        else
                        {
                            cursor = startCursor0;
                        }
                    }
                    else
                    {
                        cursor = startCursor0;
                    }
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            this.storage[storageKey] = r0;
            return r0;
        }

        private IParseResult<string> add(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, "+");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 22 "MathExpressionParser.peg"
                  "+"
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> sub(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, "-");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 23 "MathExpressionParser.peg"
                  "-"
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> mul(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, "*");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 24 "MathExpressionParser.peg"
                  "*"
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> div(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, "/");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 25 "MathExpressionParser.peg"
                  "/"
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> lParen(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, "(");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 26 "MathExpressionParser.peg"
                  "("
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> rParen(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            r1 = this.ParseLiteral(ref cursor, ")");
            if (r1 != null)
            {
                IParseResult<IList<string>> r2 = null;
                r2 = this.__(ref cursor);
                if (r2 != null)
                {
                    r0 = this.ReturnHelper<string>(startCursor0, cursor, state =>
                        #line 27 "MathExpressionParser.peg"
                  ")"
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<
            #line 29 "MathExpressionParser.peg"
         decimal
            #line default
            > @decimal(ref Cursor cursor)
        {
            IParseResult<decimal> r0 = null;
            var startCursor0 = cursor;
            IParseResult<string> r1 = null;
            var valueStart = cursor;
            var startCursor1 = cursor;
            IParseResult<IList<string>> r2 = null;
            var startCursor2 = cursor;
            var l0 = new List<string>();
            while (true)
            {
                IParseResult<string> r3 = null;
                r3 = this.ParseClass(ref cursor, "09");
                if (r3 != null)
                {
                    l0.Add(r3.Value);
                }
                else
                {
                    break;
                }
            }
            if (l0.Count >= 1)
            {
                r2 = new ParseResult<IList<string>>(startCursor2, cursor, l0.AsReadOnly());
            }
            else
            {
                cursor = startCursor2;
            }
            if (r2 != null)
            {
                IParseResult<IList<string>> r4 = null;
                var startCursor3 = cursor;
                var l1 = new List<string>();
                while (l1.Count < 1)
                {
                    IParseResult<string> r5 = null;
                    var startCursor4 = cursor;
                    IParseResult<string> r6 = null;
                    r6 = this.ParseLiteral(ref cursor, ".");
                    if (r6 != null)
                    {
                        IParseResult<IList<string>> r7 = null;
                        var startCursor5 = cursor;
                        var l2 = new List<string>();
                        while (true)
                        {
                            IParseResult<string> r8 = null;
                            r8 = this.ParseClass(ref cursor, "09");
                            if (r8 != null)
                            {
                                l2.Add(r8.Value);
                            }
                            else
                            {
                                break;
                            }
                        }
                        if (l2.Count >= 1)
                        {
                            r7 = new ParseResult<IList<string>>(startCursor5, cursor, l2.AsReadOnly());
                        }
                        else
                        {
                            cursor = startCursor5;
                        }
                        if (r7 != null)
                        {
                            var len = cursor.Location - startCursor4.Location;
                            r5 = new ParseResult<string>(startCursor4, cursor, cursor.Subject.Substring(startCursor4.Location, len));
                        }
                        else
                        {
                            cursor = startCursor4;
                        }
                    }
                    else
                    {
                        cursor = startCursor4;
                    }
                    if (r5 != null)
                    {
                        l1.Add(r5.Value);
                    }
                    else
                    {
                        break;
                    }
                }
                if (l1.Count >= 0)
                {
                    r4 = new ParseResult<IList<string>>(startCursor3, cursor, l1.AsReadOnly());
                }
                else
                {
                    cursor = startCursor3;
                }
                if (r4 != null)
                {
                    var len = cursor.Location - startCursor1.Location;
                    r1 = new ParseResult<string>(startCursor1, cursor, cursor.Subject.Substring(startCursor1.Location, len));
                }
                else
                {
                    cursor = startCursor1;
                }
            }
            else
            {
                cursor = startCursor1;
            }
            var valueEnd = cursor;
            var value = ValueOrDefault(r1);
            if (r1 != null)
            {
                IParseResult<IList<string>> r9 = null;
                r9 = this.__(ref cursor);
                if (r9 != null)
                {
                    r0 = this.ReturnHelper<decimal>(startCursor0, cursor, state =>
                        #line 30 "MathExpressionParser.peg"
                                      decimal.Parse(value)
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor0;
                }
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<IList<string>> __(ref Cursor cursor)
        {
            IParseResult<IList<string>> r0 = null;
            var startCursor0 = cursor;
            var l0 = new List<string>();
            while (true)
            {
                IParseResult<string> r1 = null;
                r1 = this.ParseClass(ref cursor, "  \t\t\r\r\n\n");
                if (r1 != null)
                {
                    l0.Add(r1.Value);
                }
                else
                {
                    break;
                }
            }
            if (l0.Count >= 0)
            {
                r0 = new ParseResult<IList<string>>(startCursor0, cursor, l0.AsReadOnly());
            }
            else
            {
                cursor = startCursor0;
            }
            return r0;
        }

        private IParseResult<string> EOF(ref Cursor cursor)
        {
            IParseResult<string> r0 = null;
            if (r0 == null)
            {
                var startCursor0 = cursor;
                IParseResult<string> r1 = null;
                r1 = this.ParseAny(ref cursor);
                cursor = startCursor0;
                if (r1 == null)
                {
                    r0 = new ParseResult<string>(cursor, cursor, string.Empty);
                }
            }
            if (r0 == null)
            {
                var startCursor1 = cursor;
                IParseResult<string> r2 = null;
                var unexpectedStart = cursor;
                r2 = this.ParseAny(ref cursor);
                var unexpectedEnd = cursor;
                var unexpected = ValueOrDefault(r2);
                if (r2 != null)
                {
                    throw this.ExceptionHelper(startCursor1, state =>
                        #line 36 "MathExpressionParser.peg"
                         "Unexpected character '" + unexpected + "'."
                        #line default
                        );
                }
                else
                {
                    cursor = startCursor1;
                }
            }
            return r0;
        }

        private IParseResult<string> ParseLiteral(ref Cursor cursor, string literal, bool ignoreCase = false)
        {
            if (cursor.Location + literal.Length <= cursor.Subject.Length)
            {
                var substr = cursor.Subject.Substring(cursor.Location, literal.Length);
                if (ignoreCase ? substr.Equals(literal, StringComparison.OrdinalIgnoreCase) : substr == literal)
                {
                    var endCursor = cursor.Advance(substr.Length);
                    var result = new ParseResult<string>(cursor, endCursor, substr);
                    cursor = endCursor;
                    return result;
                }
            }
            return null;
        }

        private IParseResult<string> ParseClass(ref Cursor cursor, string characterRanges, bool negated = false, bool ignoreCase = false)
        {
            if (cursor.Location + 1 <= cursor.Subject.Length)
            {
                var c = cursor.Subject[cursor.Location];
                bool match = false;
                for (int i = 0; !match && i < characterRanges.Length; i += 2)
                {
                    match = c >= characterRanges[i] && c <= characterRanges[i + 1];
                }
                if (!match && ignoreCase && (char.IsUpper(c) || char.IsLower(c)))
                {
                    var cs = c.ToString();
                    for (int i = 0; !match && i < characterRanges.Length; i += 2)
                    {
                        var min = characterRanges[i];
                        var max = characterRanges[i + 1];
                        for (char o = min; !match && o <= max; o++)
                        {
                            match = (char.IsUpper(o) || char.IsLower(o)) && cs.Equals(o.ToString(), StringComparison.CurrentCultureIgnoreCase);
                        }
                    }
                }
                if (match ^ negated)
                {
                    var endCursor = cursor.Advance(1);
                    var result = new ParseResult<string>(cursor, endCursor, cursor.Subject.Substring(cursor.Location, 1));
                    cursor = endCursor;
                    return result;
                }
            }
            return null;
        }

        private IParseResult<string> ParseAny(ref Cursor cursor)
        {
            if (cursor.Location + 1 <= cursor.Subject.Length)
            {
                var substr = cursor.Subject.Substring(cursor.Location, 1);
                var endCursor = cursor.Advance(1);
                var result = new ParseResult<string>(cursor, endCursor, substr);
                cursor = endCursor;
                return result;
            }
            return null;
        }

        private IParseResult<T> ReturnHelper<T>(Cursor startCursor, Cursor endCursor, Func<Cursor, T> wrappedCode)
        {
            return new ParseResult<T>(startCursor, endCursor, wrappedCode(endCursor));
        }

        private Exception ExceptionHelper(Cursor cursor, Func<Cursor, string> wrappedCode)
        {
            var ex = new FormatException(wrappedCode(cursor));
            ex.Data["cursor"] = cursor;
            return ex;
        }

        private T ValueOrDefault<T>(IParseResult<T> result)
        {
            return result == null
                ? default(T)
                : result.Value;
        }
    }
}
